<<<<<<< HEAD
import type * as estree from 'estree';

declare module 'estree' {
	export interface Decorator extends estree.BaseNode {
		type: 'Decorator';
		expression: estree.Expression;
	}
	interface PropertyDefinition {
		decorators: estree.Decorator[];
	}
	interface MethodDefinition {
		decorators: estree.Decorator[];
	}
	interface BaseClass {
		decorators: estree.Decorator[];
	}
}

export const VERSION: string;

// utils
type NullValue = null | undefined | void;
type MaybeArray<T> = T | T[];
type MaybePromise<T> = T | Promise<T>;

type PartialNull<T> = {
	[P in keyof T]: T[P] | null;
};

export interface RollupError extends RollupLog {
	name?: string | undefined;
	stack?: string | undefined;
	watchFiles?: string[] | undefined;
}

export interface RollupLog {
	binding?: string | undefined;
	cause?: unknown | undefined;
	code?: string | undefined;
	exporter?: string | undefined;
	frame?: string | undefined;
	hook?: string | undefined;
	id?: string | undefined;
	ids?: string[] | undefined;
	loc?: {
		column: number;
		file?: string | undefined;
		line: number;
	};
	message: string;
	meta?: any | undefined;
	names?: string[] | undefined;
	plugin?: string | undefined;
	pluginCode?: unknown | undefined;
	pos?: number | undefined;
	reexporter?: string | undefined;
	stack?: string | undefined;
	url?: string | undefined;
}

export type LogLevel = 'warn' | 'info' | 'debug';
export type LogLevelOption = LogLevel | 'silent';

=======
export const VERSION: string;

export interface RollupError extends RollupLogProps {
	parserError?: Error;
	stack?: string;
	watchFiles?: string[];
}

export interface RollupWarning extends RollupLogProps {
	chunkName?: string;
	cycle?: string[];
	exportName?: string;
	exporter?: string;
	guess?: string;
	importer?: string;
	missing?: string;
	modules?: string[];
	names?: string[];
	reexporter?: string;
	source?: string;
	sources?: string[];
}

export interface RollupLogProps {
	code?: string;
	frame?: string;
	hook?: string;
	id?: string;
	loc?: {
		column: number;
		file?: string;
		line: number;
	};
	message: string;
	name?: string;
	plugin?: string;
	pluginCode?: string;
	pos?: number;
	url?: string;
}

>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
export type SourceMapSegment =
	| [number]
	| [number, number, number, number]
	| [number, number, number, number, number];

export interface ExistingDecodedSourceMap {
<<<<<<< HEAD
	file?: string | undefined;
	readonly mappings: SourceMapSegment[][];
	names: string[];
	sourceRoot?: string | undefined;
	sources: string[];
	sourcesContent?: string[] | undefined;
	version: number;
	x_google_ignoreList?: number[] | undefined;
}

export interface ExistingRawSourceMap {
	file?: string | undefined;
	mappings: string;
	names: string[];
	sourceRoot?: string | undefined;
	sources: string[];
	sourcesContent?: string[] | undefined;
	version: number;
	x_google_ignoreList?: number[] | undefined;
=======
	file?: string;
	mappings: SourceMapSegment[][];
	names: string[];
	sourceRoot?: string;
	sources: string[];
	sourcesContent?: string[];
	version: number;
}

export interface ExistingRawSourceMap {
	file?: string;
	mappings: string;
	names: string[];
	sourceRoot?: string;
	sources: string[];
	sourcesContent?: string[];
	version: number;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export type DecodedSourceMapOrMissing =
	| {
<<<<<<< HEAD
			missing: true;
			plugin: string;
	  }
	| (ExistingDecodedSourceMap & { missing?: false | undefined });
=======
			mappings?: never;
			missing: true;
			plugin: string;
	  }
	| ExistingDecodedSourceMap;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export interface SourceMap {
	file: string;
	mappings: string;
	names: string[];
	sources: string[];
<<<<<<< HEAD
	sourcesContent?: string[] | undefined;
	version: number;
	debugId?: string | undefined;
=======
	sourcesContent: string[];
	version: number;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	toString(): string;
	toUrl(): string;
}

export type SourceMapInput = ExistingRawSourceMap | string | null | { mappings: '' };

<<<<<<< HEAD
interface ModuleOptions {
	attributes: Record<string, string>;
=======
type PartialNull<T> = {
	[P in keyof T]: T[P] | null;
};

interface ModuleOptions {
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	meta: CustomPluginOptions;
	moduleSideEffects: boolean | 'no-treeshake';
	syntheticNamedExports: boolean | string;
}

export interface SourceDescription extends Partial<PartialNull<ModuleOptions>> {
<<<<<<< HEAD
	ast?: ProgramNode | undefined;
	code: string;
	map?: SourceMapInput | undefined;
}

export interface TransformModuleJSON {
	ast?: ProgramNode | undefined;
	code: string;
	safeVariableNames: Record<string, string> | null;
=======
	ast?: AcornNode;
	code: string;
	map?: SourceMapInput;
}

export interface TransformModuleJSON {
	ast?: AcornNode;
	code: string;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	// note if plugins use new this.cache to opt-out auto transform cache
	customTransformCache: boolean;
	originalCode: string;
	originalSourcemap: ExistingDecodedSourceMap | null;
	sourcemapChain: DecodedSourceMapOrMissing[];
	transformDependencies: string[];
}

export interface ModuleJSON extends TransformModuleJSON, ModuleOptions {
<<<<<<< HEAD
	safeVariableNames: Record<string, string> | null;
	ast: ProgramNode;
=======
	ast: AcornNode;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	dependencies: string[];
	id: string;
	resolvedIds: ResolvedIdMap;
	transformFiles: EmittedFile[] | undefined;
}

export interface PluginCache {
	delete(id: string): boolean;
	get<T = any>(id: string): T;
	has(id: string): boolean;
	set<T = any>(id: string, value: T): void;
}

<<<<<<< HEAD
export type LoggingFunction = (log: RollupLog | string | (() => RollupLog | string)) => void;

export interface MinimalPluginContext {
	debug: LoggingFunction;
	error: (error: RollupError | string) => never;
	info: LoggingFunction;
	meta: PluginContextMeta;
	warn: LoggingFunction;
}

export interface EmittedAsset {
	fileName?: string | undefined;
	name?: string | undefined;
	needsCodeReference?: boolean | undefined;
	originalFileName?: string | null | undefined;
	source?: string | Uint8Array | undefined;
=======
export interface MinimalPluginContext {
	meta: PluginContextMeta;
}

export interface EmittedAsset {
	fileName?: string;
	name?: string;
	source?: string | Uint8Array;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	type: 'asset';
}

export interface EmittedChunk {
<<<<<<< HEAD
	fileName?: string | undefined;
	id: string;
	implicitlyLoadedAfterOneOf?: string[] | undefined;
	importer?: string | undefined;
	name?: string | undefined;
	preserveSignature?: PreserveEntrySignaturesOption | undefined;
	type: 'chunk';
}

export interface EmittedPrebuiltChunk {
	code: string;
	exports?: string[] | undefined;
	fileName: string;
	map?: SourceMap | undefined;
	sourcemapFileName?: string | undefined;
	type: 'prebuilt-chunk';
}

export type EmittedFile = EmittedAsset | EmittedChunk | EmittedPrebuiltChunk;

export type EmitFile = (emittedFile: EmittedFile) => string;

export interface ModuleInfo extends ModuleOptions {
	ast: ProgramNode | null;
=======
	fileName?: string;
	id: string;
	implicitlyLoadedAfterOneOf?: string[];
	importer?: string;
	name?: string;
	preserveSignature?: PreserveEntrySignaturesOption;
	type: 'chunk';
}

export type EmittedFile = EmittedAsset | EmittedChunk;

export type EmitAsset = (name: string, source?: string | Uint8Array) => string;

export type EmitChunk = (id: string, options?: { name?: string }) => string;

export type EmitFile = (emittedFile: EmittedFile) => string;

interface ModuleInfo extends ModuleOptions {
	ast: AcornNode | null;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	code: string | null;
	dynamicImporters: readonly string[];
	dynamicallyImportedIdResolutions: readonly ResolvedId[];
	dynamicallyImportedIds: readonly string[];
<<<<<<< HEAD
	exportedBindings: Record<string, string[]> | null;
	exports: string[] | null;
	safeVariableNames: Record<string, string> | null;
	hasDefaultExport: boolean | null;
=======
	hasDefaultExport: boolean | null;
	/** @deprecated Use `moduleSideEffects` instead */
	hasModuleSideEffects: boolean | 'no-treeshake';
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	id: string;
	implicitlyLoadedAfterOneOf: readonly string[];
	implicitlyLoadedBefore: readonly string[];
	importedIdResolutions: readonly ResolvedId[];
	importedIds: readonly string[];
	importers: readonly string[];
	isEntry: boolean;
	isExternal: boolean;
	isIncluded: boolean | null;
}

export type GetModuleInfo = (moduleId: string) => ModuleInfo | null;

<<<<<<< HEAD
// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style -- this is an interface so that it can be extended by plugins
=======
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
export interface CustomPluginOptions {
	[plugin: string]: any;
}

<<<<<<< HEAD
type LoggingFunctionWithPosition = (
	log: RollupLog | string | (() => RollupLog | string),
	pos?: number | { column: number; line: number }
) => void;

export type ParseAst = (
	input: string,
	options?: { allowReturnOutsideFunction?: boolean; jsx?: boolean }
) => ProgramNode;

// declare AbortSignal here for environments without DOM lib or @types/node
declare global {
	// eslint-disable-next-line @typescript-eslint/no-empty-object-type
	interface AbortSignal {}
}

export type ParseAstAsync = (
	input: string,
	options?: { allowReturnOutsideFunction?: boolean; jsx?: boolean; signal?: AbortSignal }
) => Promise<ProgramNode>;

export interface PluginContext extends MinimalPluginContext {
	addWatchFile: (id: string) => void;
	cache: PluginCache;
	debug: LoggingFunction;
	emitFile: EmitFile;
	error: (error: RollupError | string) => never;
	fs: RollupFsModule;
=======
export interface PluginContext extends MinimalPluginContext {
	addWatchFile: (id: string) => void;
	cache: PluginCache;
	/** @deprecated Use `this.emitFile` instead */
	emitAsset: EmitAsset;
	/** @deprecated Use `this.emitFile` instead */
	emitChunk: EmitChunk;
	emitFile: EmitFile;
	error: (err: RollupError | string, pos?: number | { column: number; line: number }) => never;
	/** @deprecated Use `this.getFileName` instead */
	getAssetFileName: (assetReferenceId: string) => string;
	/** @deprecated Use `this.getFileName` instead */
	getChunkFileName: (chunkReferenceId: string) => string;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	getFileName: (fileReferenceId: string) => string;
	getModuleIds: () => IterableIterator<string>;
	getModuleInfo: GetModuleInfo;
	getWatchFiles: () => string[];
<<<<<<< HEAD
	info: LoggingFunction;
	load: (
		options: { id: string; resolveDependencies?: boolean } & Partial<PartialNull<ModuleOptions>>
	) => Promise<ModuleInfo>;
	parse: ParseAst;
	resolve: (
		source: string,
		importer?: string,
		options?: {
			attributes?: Record<string, string>;
			custom?: CustomPluginOptions;
			isEntry?: boolean;
			skipSelf?: boolean;
		}
	) => Promise<ResolvedId | null>;
	setAssetSource: (assetReferenceId: string, source: string | Uint8Array) => void;
	warn: LoggingFunction;
=======
	/** @deprecated Use `this.resolve` instead */
	isExternal: IsExternal;
	load: (
		options: { id: string; resolveDependencies?: boolean } & Partial<PartialNull<ModuleOptions>>
	) => Promise<ModuleInfo>;
	/** @deprecated Use `this.getModuleIds` instead */
	moduleIds: IterableIterator<string>;
	parse: (input: string, options?: any) => AcornNode;
	resolve: (
		source: string,
		importer?: string,
		options?: { custom?: CustomPluginOptions; isEntry?: boolean; skipSelf?: boolean }
	) => Promise<ResolvedId | null>;
	/** @deprecated Use `this.resolve` instead */
	resolveId: (source: string, importer?: string) => Promise<string | null>;
	setAssetSource: (assetReferenceId: string, source: string | Uint8Array) => void;
	warn: (warning: RollupWarning | string, pos?: number | { column: number; line: number }) => void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export interface PluginContextMeta {
	rollupVersion: string;
	watchMode: boolean;
}

<<<<<<< HEAD
export type StringOrRegExp = string | RegExp;

export type StringFilter<Value = StringOrRegExp> =
	| MaybeArray<Value>
	| {
			include?: MaybeArray<Value> | undefined;
			exclude?: MaybeArray<Value> | undefined;
	  };

export interface HookFilter {
	id?: StringFilter | undefined;
	code?: StringFilter | undefined;
}

export interface ResolvedId extends ModuleOptions {
	external: boolean | 'absolute';
	id: string;
	resolvedBy: string;
}

export type ResolvedIdMap = Record<string, ResolvedId>;

export interface PartialResolvedId extends Partial<PartialNull<ModuleOptions>> {
	external?: boolean | 'absolute' | 'relative' | undefined;
	id: string;
	resolvedBy?: string | undefined;
}

export type ResolveIdResult = string | NullValue | false | PartialResolvedId;

export type ResolveIdResultWithoutNullValue = string | false | PartialResolvedId;
=======
export interface ResolvedId extends ModuleOptions {
	external: boolean | 'absolute';
	id: string;
}

export interface ResolvedIdMap {
	[key: string]: ResolvedId;
}

interface PartialResolvedId extends Partial<PartialNull<ModuleOptions>> {
	external?: boolean | 'absolute' | 'relative';
	id: string;
}

export type ResolveIdResult = string | false | null | void | PartialResolvedId;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type ResolveIdHook = (
	this: PluginContext,
	source: string,
	importer: string | undefined,
<<<<<<< HEAD
	options: { attributes: Record<string, string>; custom?: CustomPluginOptions; isEntry: boolean }
=======
	options: { custom?: CustomPluginOptions; isEntry: boolean }
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
) => ResolveIdResult;

export type ShouldTransformCachedModuleHook = (
	this: PluginContext,
	options: {
<<<<<<< HEAD
		ast: ProgramNode;
=======
		ast: AcornNode;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
		code: string;
		id: string;
		meta: CustomPluginOptions;
		moduleSideEffects: boolean | 'no-treeshake';
		resolvedSources: ResolvedIdMap;
		syntheticNamedExports: boolean | string;
	}
<<<<<<< HEAD
) => boolean | NullValue;
=======
) => boolean;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type IsExternal = (
	source: string,
	importer: string | undefined,
	isResolved: boolean
) => boolean;

<<<<<<< HEAD
export type HasModuleSideEffects = (id: string, external: boolean) => boolean;

export type LoadResult = SourceDescription | string | NullValue;
=======
export type IsPureModule = (id: string) => boolean | null | void;

export type HasModuleSideEffects = (id: string, external: boolean) => boolean;

export type LoadResult = SourceDescription | string | null | void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type LoadHook = (this: PluginContext, id: string) => LoadResult;

export interface TransformPluginContext extends PluginContext {
<<<<<<< HEAD
	debug: LoggingFunctionWithPosition;
	error: (error: RollupError | string, pos?: number | { column: number; line: number }) => never;
	getCombinedSourcemap: () => SourceMap;
	info: LoggingFunctionWithPosition;
	warn: LoggingFunctionWithPosition;
}

export type TransformResult = string | NullValue | Partial<SourceDescription>;
=======
	getCombinedSourcemap: () => SourceMap;
}

export type TransformResult = string | null | void | Partial<SourceDescription>;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type TransformHook = (
	this: TransformPluginContext,
	code: string,
	id: string
) => TransformResult;

export type ModuleParsedHook = (this: PluginContext, info: ModuleInfo) => void;

export type RenderChunkHook = (
	this: PluginContext,
	code: string,
	chunk: RenderedChunk,
<<<<<<< HEAD
	options: NormalizedOutputOptions,
	meta: { chunks: Record<string, RenderedChunk> }
) => { code: string; map?: SourceMapInput } | string | NullValue;

export type ResolveDynamicImportHook = (
	this: PluginContext,
	specifier: string | AstNode,
	importer: string,
	options: { attributes: Record<string, string> }
=======
	options: NormalizedOutputOptions
) => { code: string; map?: SourceMapInput } | string | null | undefined;

export type ResolveDynamicImportHook = (
	this: PluginContext,
	specifier: string | AcornNode,
	importer: string
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
) => ResolveIdResult;

export type ResolveImportMetaHook = (
	this: PluginContext,
<<<<<<< HEAD
	property: string | null,
	options: { chunkId: string; format: InternalModuleFormat; moduleId: string }
) => string | NullValue;
=======
	prop: string | null,
	options: { chunkId: string; format: InternalModuleFormat; moduleId: string }
) => string | null | void;

export type ResolveAssetUrlHook = (
	this: PluginContext,
	options: {
		assetFileName: string;
		chunkId: string;
		format: InternalModuleFormat;
		moduleId: string;
		relativeAssetPath: string;
	}
) => string | null | void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type ResolveFileUrlHook = (
	this: PluginContext,
	options: {
<<<<<<< HEAD
		chunkId: string;
=======
		assetReferenceId: string | null;
		chunkId: string;
		chunkReferenceId: string | null;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
		fileName: string;
		format: InternalModuleFormat;
		moduleId: string;
		referenceId: string;
		relativePath: string;
	}
<<<<<<< HEAD
) => string | NullValue;

export type AddonHookFunction = (
	this: PluginContext,
	chunk: RenderedChunk
) => string | Promise<string>;
=======
) => string | null | void;

export type AddonHookFunction = (this: PluginContext) => string | Promise<string>;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
export type AddonHook = string | AddonHookFunction;

export type ChangeEvent = 'create' | 'update' | 'delete';
export type WatchChangeHook = (
	this: PluginContext,
	id: string,
	change: { event: ChangeEvent }
) => void;

/**
 * use this type for plugin annotation
 * @example
 * ```ts
 * interface Options {
 * ...
 * }
 * const myPlugin: PluginImpl<Options> = (options = {}) => { ... }
 * ```
 */
<<<<<<< HEAD
export type PluginImpl<O extends object = object, A = any> = (options?: O) => Plugin<A>;

export type OutputBundle = Record<string, OutputAsset | OutputChunk>;

export type PreRenderedChunkWithFileName = PreRenderedChunk & { fileName: string };

export interface ImportedInternalChunk {
	type: 'internal';
	fileName: string;
	resolvedImportPath: string;
	chunk: PreRenderedChunk;
}

export interface ImportedExternalChunk {
	type: 'external';
	fileName: string;
	resolvedImportPath: string;
}

export type DynamicImportTargetChunk = ImportedInternalChunk | ImportedExternalChunk;

export interface FunctionPluginHooks {
	augmentChunkHash: (this: PluginContext, chunk: RenderedChunk) => string | void;
	buildEnd: (this: PluginContext, error?: Error) => void;
	buildStart: (this: PluginContext, options: NormalizedInputOptions) => void;
	closeBundle: (this: PluginContext, error?: Error) => void;
=======
// eslint-disable-next-line @typescript-eslint/ban-types
export type PluginImpl<O extends object = object> = (options?: O) => Plugin;

export interface OutputBundle {
	[fileName: string]: OutputAsset | OutputChunk;
}

export interface FunctionPluginHooks {
	augmentChunkHash: (this: PluginContext, chunk: PreRenderedChunk) => string | void;
	buildEnd: (this: PluginContext, err?: Error) => void;
	buildStart: (this: PluginContext, options: NormalizedInputOptions) => void;
	closeBundle: (this: PluginContext) => void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	closeWatcher: (this: PluginContext) => void;
	generateBundle: (
		this: PluginContext,
		options: NormalizedOutputOptions,
		bundle: OutputBundle,
		isWrite: boolean
	) => void;
	load: LoadHook;
	moduleParsed: ModuleParsedHook;
<<<<<<< HEAD
	onLog: (this: MinimalPluginContext, level: LogLevel, log: RollupLog) => boolean | NullValue;
	options: (this: MinimalPluginContext, options: InputOptions) => InputOptions | NullValue;
	outputOptions: (this: PluginContext, options: OutputOptions) => OutputOptions | NullValue;
=======
	options: (this: MinimalPluginContext, options: InputOptions) => InputOptions | null | void;
	outputOptions: (this: PluginContext, options: OutputOptions) => OutputOptions | null | void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	renderChunk: RenderChunkHook;
	renderDynamicImport: (
		this: PluginContext,
		options: {
			customResolution: string | null;
			format: InternalModuleFormat;
			moduleId: string;
			targetModuleId: string | null;
<<<<<<< HEAD
			chunk: PreRenderedChunkWithFileName;
			targetChunk: PreRenderedChunkWithFileName | null;
			getTargetChunkImports: () => DynamicImportTargetChunk[] | null;
		}
	) => { left: string; right: string } | NullValue;
	renderError: (this: PluginContext, error?: Error) => void;
=======
		}
	) => { left: string; right: string } | null | void;
	renderError: (this: PluginContext, err?: Error) => void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	renderStart: (
		this: PluginContext,
		outputOptions: NormalizedOutputOptions,
		inputOptions: NormalizedInputOptions
	) => void;
<<<<<<< HEAD
=======
	/** @deprecated Use `resolveFileUrl` instead */
	resolveAssetUrl: ResolveAssetUrlHook;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	resolveDynamicImport: ResolveDynamicImportHook;
	resolveFileUrl: ResolveFileUrlHook;
	resolveId: ResolveIdHook;
	resolveImportMeta: ResolveImportMetaHook;
	shouldTransformCachedModule: ShouldTransformCachedModuleHook;
	transform: TransformHook;
	watchChange: WatchChangeHook;
	writeBundle: (
		this: PluginContext,
		options: NormalizedOutputOptions,
		bundle: OutputBundle
	) => void;
}

export type OutputPluginHooks =
	| 'augmentChunkHash'
	| 'generateBundle'
	| 'outputOptions'
	| 'renderChunk'
	| 'renderDynamicImport'
	| 'renderError'
	| 'renderStart'
<<<<<<< HEAD
=======
	| 'resolveAssetUrl'
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	| 'resolveFileUrl'
	| 'resolveImportMeta'
	| 'writeBundle';

export type InputPluginHooks = Exclude<keyof FunctionPluginHooks, OutputPluginHooks>;

export type SyncPluginHooks =
	| 'augmentChunkHash'
<<<<<<< HEAD
	| 'onLog'
	| 'outputOptions'
	| 'renderDynamicImport'
=======
	| 'outputOptions'
	| 'renderDynamicImport'
	| 'resolveAssetUrl'
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	| 'resolveFileUrl'
	| 'resolveImportMeta';

export type AsyncPluginHooks = Exclude<keyof FunctionPluginHooks, SyncPluginHooks>;

export type FirstPluginHooks =
	| 'load'
	| 'renderDynamicImport'
<<<<<<< HEAD
=======
	| 'resolveAssetUrl'
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	| 'resolveDynamicImport'
	| 'resolveFileUrl'
	| 'resolveId'
	| 'resolveImportMeta'
	| 'shouldTransformCachedModule';

export type SequentialPluginHooks =
	| 'augmentChunkHash'
	| 'generateBundle'
<<<<<<< HEAD
	| 'onLog'
=======
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	| 'options'
	| 'outputOptions'
	| 'renderChunk'
	| 'transform';

export type ParallelPluginHooks = Exclude<
	keyof FunctionPluginHooks | AddonHooks,
	FirstPluginHooks | SequentialPluginHooks
>;

export type AddonHooks = 'banner' | 'footer' | 'intro' | 'outro';

<<<<<<< HEAD
type MakeAsync<Function_> = Function_ extends (
	this: infer This,
	...parameters: infer Arguments
) => infer Return
	? (this: This, ...parameters: Arguments) => Return | Promise<Return>
	: never;

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type ObjectHook<T, O = {}> = T | ({ handler: T; order?: 'pre' | 'post' | null } & O);

export type HookFilterExtension<K extends keyof FunctionPluginHooks> = K extends 'transform'
	? { filter?: HookFilter | undefined }
	: K extends 'load'
		? { filter?: Pick<HookFilter, 'id'> | undefined }
		: K extends 'resolveId'
			? { filter?: { id?: StringFilter<RegExp> | undefined } } | undefined
			: // eslint-disable-next-line @typescript-eslint/no-empty-object-type
				{};
=======
type MakeAsync<Fn> = Fn extends (this: infer This, ...args: infer Args) => infer Return
	? (this: This, ...args: Args) => Return | Promise<Return>
	: never;

// eslint-disable-next-line @typescript-eslint/ban-types
type ObjectHook<T, O = {}> = T | ({ handler: T; order?: 'pre' | 'post' | null } & O);
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type PluginHooks = {
	[K in keyof FunctionPluginHooks]: ObjectHook<
		K extends AsyncPluginHooks ? MakeAsync<FunctionPluginHooks[K]> : FunctionPluginHooks[K],
<<<<<<< HEAD
		// eslint-disable-next-line @typescript-eslint/no-empty-object-type
		HookFilterExtension<K> & (K extends ParallelPluginHooks ? { sequential?: boolean } : {})
=======
		// eslint-disable-next-line @typescript-eslint/ban-types
		K extends ParallelPluginHooks ? { sequential?: boolean } : {}
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	>;
};

export interface OutputPlugin
	extends Partial<{ [K in OutputPluginHooks]: PluginHooks[K] }>,
<<<<<<< HEAD
		Partial<Record<AddonHooks, ObjectHook<AddonHook>>> {
	cacheKey?: string | undefined;
	name: string;
	version?: string | undefined;
}

export interface Plugin<A = any> extends OutputPlugin, Partial<PluginHooks> {
	// for inter-plugin communication
	api?: A | undefined;
}

export type JsxPreset = 'react' | 'react-jsx' | 'preserve' | 'preserve-react';

export type NormalizedJsxOptions =
	| NormalizedJsxPreserveOptions
	| NormalizedJsxClassicOptions
	| NormalizedJsxAutomaticOptions;

interface NormalizedJsxPreserveOptions {
	factory: string | null;
	fragment: string | null;
	importSource: string | null;
	mode: 'preserve';
}

interface NormalizedJsxClassicOptions {
	factory: string;
	fragment: string;
	importSource: string | null;
	mode: 'classic';
}

interface NormalizedJsxAutomaticOptions {
	factory: string;
	importSource: string | null;
	jsxImportSource: string;
	mode: 'automatic';
}

export type JsxOptions = Partial<NormalizedJsxOptions> & {
	preset?: JsxPreset | undefined;
};

export type TreeshakingPreset = 'smallest' | 'safest' | 'recommended';
=======
		Partial<{ [K in AddonHooks]: ObjectHook<AddonHook> }> {
	cacheKey?: string;
	name: string;
}

export interface Plugin extends OutputPlugin, Partial<PluginHooks> {
	// for inter-plugin communication
	api?: any;
}

type TreeshakingPreset = 'smallest' | 'safest' | 'recommended';
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export interface NormalizedTreeshakingOptions {
	annotations: boolean;
	correctVarValueBeforeDeclaration: boolean;
<<<<<<< HEAD
	manualPureFunctions: readonly string[];
=======
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	moduleSideEffects: HasModuleSideEffects;
	propertyReadSideEffects: boolean | 'always';
	tryCatchDeoptimization: boolean;
	unknownGlobalSideEffects: boolean;
}

export interface TreeshakingOptions
	extends Partial<Omit<NormalizedTreeshakingOptions, 'moduleSideEffects'>> {
<<<<<<< HEAD
	moduleSideEffects?: ModuleSideEffectsOption | undefined;
	preset?: TreeshakingPreset | undefined;
}

interface ManualChunkMeta {
	getModuleIds: () => IterableIterator<string>;
	getModuleInfo: GetModuleInfo;
}

export type GetManualChunk = (id: string, meta: ManualChunkMeta) => string | NullValue;
=======
	moduleSideEffects?: ModuleSideEffectsOption;
	preset?: TreeshakingPreset;
	/** @deprecated Use `moduleSideEffects` instead */
	pureExternalModules?: PureModulesOption;
}

interface GetManualChunkApi {
	getModuleIds: () => IterableIterator<string>;
	getModuleInfo: GetModuleInfo;
}
export type GetManualChunk = (id: string, api: GetManualChunkApi) => string | null | void;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type ExternalOption =
	| (string | RegExp)[]
	| string
	| RegExp
<<<<<<< HEAD
	| ((source: string, importer: string | undefined, isResolved: boolean) => boolean | NullValue);

export type GlobalsOption = Record<string, string> | ((name: string) => string);

export type InputOption = string | string[] | Record<string, string>;

export type ManualChunksOption = Record<string, string[]> | GetManualChunk;

export type LogHandlerWithDefault = (
	level: LogLevel,
	log: RollupLog,
	defaultHandler: LogOrStringHandler
) => void;

export type LogOrStringHandler = (level: LogLevel | 'error', log: RollupLog | string) => void;

export type LogHandler = (level: LogLevel, log: RollupLog) => void;

export type ModuleSideEffectsOption = boolean | 'no-external' | string[] | HasModuleSideEffects;

export type PreserveEntrySignaturesOption = false | 'strict' | 'allow-extension' | 'exports-only';

=======
	| ((source: string, importer: string | undefined, isResolved: boolean) => boolean | null | void);
export type PureModulesOption = boolean | string[] | IsPureModule;
export type GlobalsOption = { [name: string]: string } | ((name: string) => string);
export type InputOption = string | string[] | { [entryAlias: string]: string };
export type ManualChunksOption = { [chunkAlias: string]: string[] } | GetManualChunk;
export type ModuleSideEffectsOption = boolean | 'no-external' | string[] | HasModuleSideEffects;
export type PreserveEntrySignaturesOption = false | 'strict' | 'allow-extension' | 'exports-only';
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
export type SourcemapPathTransformOption = (
	relativeSourcePath: string,
	sourcemapPath: string
) => string;

<<<<<<< HEAD
export type SourcemapIgnoreListOption = (
	relativeSourcePath: string,
	sourcemapPath: string
) => boolean;

export type InputPluginOption = MaybePromise<Plugin | NullValue | false | InputPluginOption[]>;

export interface InputOptions {
	cache?: boolean | RollupCache | undefined;
	context?: string | undefined;
	experimentalCacheExpiry?: number | undefined;
	experimentalLogSideEffects?: boolean | undefined;
	external?: ExternalOption | undefined;
	fs?: RollupFsModule | undefined;
	input?: InputOption | undefined;
	jsx?: false | JsxPreset | JsxOptions | undefined;
	logLevel?: LogLevelOption | undefined;
	makeAbsoluteExternalsRelative?: boolean | 'ifRelativeSource' | undefined;
	maxParallelFileOps?: number | undefined;
	moduleContext?: ((id: string) => string | NullValue) | Record<string, string> | undefined;
	onLog?: LogHandlerWithDefault | undefined;
	onwarn?: WarningHandlerWithDefault | undefined;
	perf?: boolean | undefined;
	plugins?: InputPluginOption | undefined;
	preserveEntrySignatures?: PreserveEntrySignaturesOption | undefined;
	preserveSymlinks?: boolean | undefined;
	shimMissingExports?: boolean | undefined;
	strictDeprecations?: boolean | undefined;
	treeshake?: boolean | TreeshakingPreset | TreeshakingOptions | undefined;
	watch?: WatcherOptions | false | undefined;
}

export interface InputOptionsWithPlugins extends InputOptions {
	plugins: Plugin[];
}

export interface NormalizedInputOptions {
	cache: false | undefined | RollupCache;
	context: string;
	experimentalCacheExpiry: number;
	experimentalLogSideEffects: boolean;
	external: IsExternal;
	fs: RollupFsModule;
	input: string[] | Record<string, string>;
	jsx: false | NormalizedJsxOptions;
	logLevel: LogLevelOption;
	makeAbsoluteExternalsRelative: boolean | 'ifRelativeSource';
	maxParallelFileOps: number;
	moduleContext: (id: string) => string;
	onLog: LogHandler;
	perf: boolean;
	plugins: Plugin[];
	preserveEntrySignatures: PreserveEntrySignaturesOption;
=======
export interface InputOptions {
	acorn?: Record<string, unknown>;
	acornInjectPlugins?: (() => unknown)[] | (() => unknown);
	cache?: false | RollupCache;
	context?: string;
	experimentalCacheExpiry?: number;
	external?: ExternalOption;
	/** @deprecated Use the "inlineDynamicImports" output option instead. */
	inlineDynamicImports?: boolean;
	input?: InputOption;
	makeAbsoluteExternalsRelative?: boolean | 'ifRelativeSource';
	/** @deprecated Use the "manualChunks" output option instead. */
	manualChunks?: ManualChunksOption;
	maxParallelFileOps?: number;
	/** @deprecated Use the "maxParallelFileOps" option instead. */
	maxParallelFileReads?: number;
	moduleContext?: ((id: string) => string | null | void) | { [id: string]: string };
	onwarn?: WarningHandlerWithDefault;
	perf?: boolean;
	plugins?: (Plugin | null | false | undefined)[];
	preserveEntrySignatures?: PreserveEntrySignaturesOption;
	/** @deprecated Use the "preserveModules" output option instead. */
	preserveModules?: boolean;
	preserveSymlinks?: boolean;
	shimMissingExports?: boolean;
	strictDeprecations?: boolean;
	treeshake?: boolean | TreeshakingPreset | TreeshakingOptions;
	watch?: WatcherOptions | false;
}

export interface NormalizedInputOptions {
	acorn: Record<string, unknown>;
	acornInjectPlugins: (() => unknown)[];
	cache: false | undefined | RollupCache;
	context: string;
	experimentalCacheExpiry: number;
	external: IsExternal;
	/** @deprecated Use the "inlineDynamicImports" output option instead. */
	inlineDynamicImports: boolean | undefined;
	input: string[] | { [entryAlias: string]: string };
	makeAbsoluteExternalsRelative: boolean | 'ifRelativeSource';
	/** @deprecated Use the "manualChunks" output option instead. */
	manualChunks: ManualChunksOption | undefined;
	maxParallelFileOps: number;
	/** @deprecated Use the "maxParallelFileOps" option instead. */
	maxParallelFileReads: number;
	moduleContext: (id: string) => string;
	onwarn: WarningHandler;
	perf: boolean;
	plugins: Plugin[];
	preserveEntrySignatures: PreserveEntrySignaturesOption;
	/** @deprecated Use the "preserveModules" output option instead. */
	preserveModules: boolean | undefined;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	preserveSymlinks: boolean;
	shimMissingExports: boolean;
	strictDeprecations: boolean;
	treeshake: false | NormalizedTreeshakingOptions;
}

export type InternalModuleFormat = 'amd' | 'cjs' | 'es' | 'iife' | 'system' | 'umd';
<<<<<<< HEAD
export type ImportAttributesKey = 'with' | 'assert';
=======
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type ModuleFormat = InternalModuleFormat | 'commonjs' | 'esm' | 'module' | 'systemjs';

type GeneratedCodePreset = 'es5' | 'es2015';

interface NormalizedGeneratedCodeOptions {
	arrowFunctions: boolean;
	constBindings: boolean;
	objectShorthand: boolean;
	reservedNamesAsProps: boolean;
	symbols: boolean;
}

interface GeneratedCodeOptions extends Partial<NormalizedGeneratedCodeOptions> {
<<<<<<< HEAD
	preset?: GeneratedCodePreset | undefined;
=======
	preset?: GeneratedCodePreset;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export type OptionsPaths = Record<string, string> | ((id: string) => string);

<<<<<<< HEAD
export type InteropType = 'compat' | 'auto' | 'esModule' | 'default' | 'defaultOnly';
=======
export type InteropType = boolean | 'auto' | 'esModule' | 'default' | 'defaultOnly';
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export type GetInterop = (id: string | null) => InteropType;

export type AmdOptions = (
	| {
<<<<<<< HEAD
			autoId?: false | undefined;
=======
			autoId?: false;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
			id: string;
	  }
	| {
			autoId: true;
<<<<<<< HEAD
			basePath?: string | undefined;
			id?: undefined | undefined;
	  }
	| {
			autoId?: false | undefined;
			id?: undefined | undefined;
	  }
) & {
	define?: string | undefined;
	forceJsExtensionForImports?: boolean | undefined;
=======
			basePath?: string;
			id?: undefined;
	  }
	| {
			autoId?: false;
			id?: undefined;
	  }
) & {
	define?: string;
	forceJsExtensionForImports?: boolean;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
};

export type NormalizedAmdOptions = (
	| {
			autoId: false;
<<<<<<< HEAD
			id?: string | undefined;
=======
			id?: string;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	  }
	| {
			autoId: true;
			basePath: string;
	  }
) & {
	define: string;
	forceJsExtensionForImports: boolean;
};

<<<<<<< HEAD
type AddonFunction = (chunk: RenderedChunk) => string | Promise<string>;

type OutputPluginOption = MaybePromise<OutputPlugin | NullValue | false | OutputPluginOption[]>;

type HashCharacters = 'base64' | 'base36' | 'hex';

export interface OutputOptions {
	amd?: AmdOptions | undefined;
	assetFileNames?: string | ((chunkInfo: PreRenderedAsset) => string) | undefined;
	banner?: string | AddonFunction | undefined;
	chunkFileNames?: string | ((chunkInfo: PreRenderedChunk) => string) | undefined;
	compact?: boolean | undefined;
	// only required for bundle.write
	dir?: string | undefined;
	dynamicImportInCjs?: boolean | undefined;
	entryFileNames?: string | ((chunkInfo: PreRenderedChunk) => string) | undefined;
	esModule?: boolean | 'if-default-prop' | undefined;
	experimentalMinChunkSize?: number | undefined;
	exports?: 'default' | 'named' | 'none' | 'auto' | undefined;
	extend?: boolean | undefined;
	/** @deprecated Use "externalImportAttributes" instead. */
	externalImportAssertions?: boolean | undefined;
	externalImportAttributes?: boolean | undefined;
	externalLiveBindings?: boolean | undefined;
	// only required for bundle.write
	file?: string | undefined;
	footer?: string | AddonFunction | undefined;
	format?: ModuleFormat | undefined;
	freeze?: boolean | undefined;
	generatedCode?: GeneratedCodePreset | GeneratedCodeOptions | undefined;
	globals?: GlobalsOption | undefined;
	hashCharacters?: HashCharacters | undefined;
	hoistTransitiveImports?: boolean | undefined;
	importAttributesKey?: ImportAttributesKey | undefined;
	indent?: string | boolean | undefined;
	inlineDynamicImports?: boolean | undefined;
	interop?: InteropType | GetInterop | undefined;
	intro?: string | AddonFunction | undefined;
	manualChunks?: ManualChunksOption | undefined;
	minifyInternalExports?: boolean | undefined;
	name?: string | undefined;
	noConflict?: boolean | undefined;
	/** @deprecated This will be the new default in Rollup 5. */
	onlyExplicitManualChunks?: boolean | undefined;
	outro?: string | AddonFunction | undefined;
	paths?: OptionsPaths | undefined;
	plugins?: OutputPluginOption | undefined;
	preserveModules?: boolean | undefined;
	preserveModulesRoot?: string | undefined;
	reexportProtoFromExternal?: boolean | undefined;
	sanitizeFileName?: boolean | ((fileName: string) => string) | undefined;
	sourcemap?: boolean | 'inline' | 'hidden' | undefined;
	sourcemapBaseUrl?: string | undefined;
	sourcemapExcludeSources?: boolean | undefined;
	sourcemapFile?: string | undefined;
	sourcemapFileNames?: string | ((chunkInfo: PreRenderedChunk) => string) | undefined;
	sourcemapIgnoreList?: boolean | SourcemapIgnoreListOption | undefined;
	sourcemapPathTransform?: SourcemapPathTransformOption | undefined;
	sourcemapDebugIds?: boolean | undefined;
	strict?: boolean | undefined;
	systemNullSetters?: boolean | undefined;
	validate?: boolean | undefined;
	virtualDirname?: string | undefined;
=======
export interface OutputOptions {
	amd?: AmdOptions;
	assetFileNames?: string | ((chunkInfo: PreRenderedAsset) => string);
	banner?: string | (() => string | Promise<string>);
	chunkFileNames?: string | ((chunkInfo: PreRenderedChunk) => string);
	compact?: boolean;
	// only required for bundle.write
	dir?: string;
	/** @deprecated Use the "renderDynamicImport" plugin hook instead. */
	dynamicImportFunction?: string;
	entryFileNames?: string | ((chunkInfo: PreRenderedChunk) => string);
	esModule?: boolean;
	exports?: 'default' | 'named' | 'none' | 'auto';
	extend?: boolean;
	externalLiveBindings?: boolean;
	// only required for bundle.write
	file?: string;
	footer?: string | (() => string | Promise<string>);
	format?: ModuleFormat;
	freeze?: boolean;
	generatedCode?: GeneratedCodePreset | GeneratedCodeOptions;
	globals?: GlobalsOption;
	hoistTransitiveImports?: boolean;
	indent?: string | boolean;
	inlineDynamicImports?: boolean;
	interop?: InteropType | GetInterop;
	intro?: string | (() => string | Promise<string>);
	manualChunks?: ManualChunksOption;
	minifyInternalExports?: boolean;
	name?: string;
	/** @deprecated Use "generatedCode.symbols" instead. */
	namespaceToStringTag?: boolean;
	noConflict?: boolean;
	outro?: string | (() => string | Promise<string>);
	paths?: OptionsPaths;
	plugins?: (OutputPlugin | null | false | undefined)[];
	/** @deprecated Use "generatedCode.constBindings" instead. */
	preferConst?: boolean;
	preserveModules?: boolean;
	preserveModulesRoot?: string;
	sanitizeFileName?: boolean | ((fileName: string) => string);
	sourcemap?: boolean | 'inline' | 'hidden';
	sourcemapBaseUrl?: string;
	sourcemapExcludeSources?: boolean;
	sourcemapFile?: string;
	sourcemapPathTransform?: SourcemapPathTransformOption;
	strict?: boolean;
	systemNullSetters?: boolean;
	validate?: boolean;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export interface NormalizedOutputOptions {
	amd: NormalizedAmdOptions;
	assetFileNames: string | ((chunkInfo: PreRenderedAsset) => string);
<<<<<<< HEAD
	banner: AddonFunction;
	chunkFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
	compact: boolean;
	dir: string | undefined;
	dynamicImportInCjs: boolean;
	entryFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
	esModule: boolean | 'if-default-prop';
	experimentalMinChunkSize: number;
	exports: 'default' | 'named' | 'none' | 'auto';
	extend: boolean;
	/** @deprecated Use "externalImportAttributes" instead. */
	externalImportAssertions: boolean;
	externalImportAttributes: boolean;
	externalLiveBindings: boolean;
	file: string | undefined;
	footer: AddonFunction;
=======
	banner: () => string | Promise<string>;
	chunkFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
	compact: boolean;
	dir: string | undefined;
	/** @deprecated Use the "renderDynamicImport" plugin hook instead. */
	dynamicImportFunction: string | undefined;
	entryFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
	esModule: boolean;
	exports: 'default' | 'named' | 'none' | 'auto';
	extend: boolean;
	externalLiveBindings: boolean;
	file: string | undefined;
	footer: () => string | Promise<string>;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	format: InternalModuleFormat;
	freeze: boolean;
	generatedCode: NormalizedGeneratedCodeOptions;
	globals: GlobalsOption;
<<<<<<< HEAD
	hashCharacters: HashCharacters;
	hoistTransitiveImports: boolean;
	importAttributesKey: ImportAttributesKey;
	indent: true | string;
	inlineDynamicImports: boolean;
	interop: GetInterop;
	intro: AddonFunction;
	manualChunks: ManualChunksOption;
	minifyInternalExports: boolean;
	name: string | undefined;
	noConflict: boolean;
	onlyExplicitManualChunks: boolean;
	outro: AddonFunction;
	paths: OptionsPaths;
	plugins: OutputPlugin[];
	preserveModules: boolean;
	preserveModulesRoot: string | undefined;
	reexportProtoFromExternal: boolean;
=======
	hoistTransitiveImports: boolean;
	indent: true | string;
	inlineDynamicImports: boolean;
	interop: GetInterop;
	intro: () => string | Promise<string>;
	manualChunks: ManualChunksOption;
	minifyInternalExports: boolean;
	name: string | undefined;
	namespaceToStringTag: boolean;
	noConflict: boolean;
	outro: () => string | Promise<string>;
	paths: OptionsPaths;
	plugins: OutputPlugin[];
	/** @deprecated Use the "renderDynamicImport" plugin hook instead. */
	preferConst: boolean;
	preserveModules: boolean;
	preserveModulesRoot: string | undefined;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	sanitizeFileName: (fileName: string) => string;
	sourcemap: boolean | 'inline' | 'hidden';
	sourcemapBaseUrl: string | undefined;
	sourcemapExcludeSources: boolean;
	sourcemapFile: string | undefined;
<<<<<<< HEAD
	sourcemapFileNames: string | ((chunkInfo: PreRenderedChunk) => string) | undefined;
	sourcemapIgnoreList: SourcemapIgnoreListOption;
	sourcemapPathTransform: SourcemapPathTransformOption | undefined;
	sourcemapDebugIds: boolean;
	strict: boolean;
	systemNullSetters: boolean;
	validate: boolean;
	virtualDirname: string;
}

export type WarningHandlerWithDefault = (
	warning: RollupLog,
	defaultHandler: LoggingFunction
) => void;

export type SerializedTimings = Record<string, [number, number, number]>;

export interface PreRenderedAsset {
	/** @deprecated Use "names" instead. */
	name: string | undefined;
	names: string[];
	/** @deprecated Use "originalFileNames" instead. */
	originalFileName: string | null;
	originalFileNames: string[];
=======
	sourcemapPathTransform: SourcemapPathTransformOption | undefined;
	strict: boolean;
	systemNullSetters: boolean;
	validate: boolean;
}

export type WarningHandlerWithDefault = (
	warning: RollupWarning,
	defaultHandler: WarningHandler
) => void;
export type WarningHandler = (warning: RollupWarning) => void;

export interface SerializedTimings {
	[label: string]: [number, number, number];
}

export interface PreRenderedAsset {
	name: string | undefined;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	source: string | Uint8Array;
	type: 'asset';
}

export interface OutputAsset extends PreRenderedAsset {
	fileName: string;
<<<<<<< HEAD
	needsCodeReference: boolean;
}

export interface RenderedModule {
	readonly code: string | null;
=======
	/** @deprecated Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead */
	isAsset: true;
}

export interface RenderedModule {
	code: string | null;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	originalLength: number;
	removedExports: string[];
	renderedExports: string[];
	renderedLength: number;
}

export interface PreRenderedChunk {
	exports: string[];
	facadeModuleId: string | null;
	isDynamicEntry: boolean;
	isEntry: boolean;
	isImplicitEntry: boolean;
<<<<<<< HEAD
	moduleIds: string[];
=======
	modules: {
		[id: string]: RenderedModule;
	};
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	name: string;
	type: 'chunk';
}

export interface RenderedChunk extends PreRenderedChunk {
<<<<<<< HEAD
	dynamicImports: string[];
	fileName: string;
	implicitlyLoadedBefore: string[];
	importedBindings: Record<string, string[]>;
	imports: string[];
	modules: Record<string, RenderedModule>;
=======
	code?: string;
	dynamicImports: string[];
	fileName: string;
	implicitlyLoadedBefore: string[];
	importedBindings: {
		[imported: string]: string[];
	};
	imports: string[];
	map?: SourceMap;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	referencedFiles: string[];
}

export interface OutputChunk extends RenderedChunk {
	code: string;
<<<<<<< HEAD
	map: SourceMap | null;
	sourcemapFileName: string | null;
	preliminaryFileName: string;
}

export type SerializablePluginCache = Record<string, [number, any]>;
=======
}

export interface SerializablePluginCache {
	[key: string]: [number, any];
}
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235

export interface RollupCache {
	modules: ModuleJSON[];
	plugins?: Record<string, SerializablePluginCache>;
}

export interface RollupOutput {
	output: [OutputChunk, ...(OutputChunk | OutputAsset)[]];
}

export interface RollupBuild {
	cache: RollupCache | undefined;
	close: () => Promise<void>;
	closed: boolean;
<<<<<<< HEAD
	[Symbol.asyncDispose](): Promise<void>;
	generate: (outputOptions: OutputOptions) => Promise<RollupOutput>;
	getTimings?: (() => SerializedTimings) | undefined;
=======
	generate: (outputOptions: OutputOptions) => Promise<RollupOutput>;
	getTimings?: () => SerializedTimings;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	watchFiles: string[];
	write: (options: OutputOptions) => Promise<RollupOutput>;
}

export interface RollupOptions extends InputOptions {
	// This is included for compatibility with config files but ignored by rollup.rollup
<<<<<<< HEAD
	output?: OutputOptions | OutputOptions[] | undefined;
}

export interface MergedRollupOptions extends InputOptionsWithPlugins {
=======
	output?: OutputOptions | OutputOptions[];
}

export interface MergedRollupOptions extends InputOptions {
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	output: OutputOptions[];
}

export function rollup(options: RollupOptions): Promise<RollupBuild>;

export interface ChokidarOptions {
<<<<<<< HEAD
	alwaysStat?: boolean | undefined;
	atomic?: boolean | number | undefined;
	awaitWriteFinish?:
		| {
				pollInterval?: number | undefined;
				stabilityThreshold?: number | undefined;
		  }
		| boolean
		| undefined;
	binaryInterval?: number | undefined;
	cwd?: string | undefined;
	depth?: number | undefined;
	disableGlobbing?: boolean | undefined;
	followSymlinks?: boolean | undefined;
	ignoreInitial?: boolean | undefined;
	ignorePermissionErrors?: boolean | undefined;
	ignored?: any | undefined;
	interval?: number | undefined;
	persistent?: boolean | undefined;
	useFsEvents?: boolean | undefined;
	usePolling?: boolean | undefined;
=======
	alwaysStat?: boolean;
	atomic?: boolean | number;
	awaitWriteFinish?:
		| {
				pollInterval?: number;
				stabilityThreshold?: number;
		  }
		| boolean;
	binaryInterval?: number;
	cwd?: string;
	depth?: number;
	disableGlobbing?: boolean;
	followSymlinks?: boolean;
	ignoreInitial?: boolean;
	ignorePermissionErrors?: boolean;
	ignored?: any;
	interval?: number;
	persistent?: boolean;
	useFsEvents?: boolean;
	usePolling?: boolean;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export type RollupWatchHooks = 'onError' | 'onStart' | 'onBundleStart' | 'onBundleEnd' | 'onEnd';

export interface WatcherOptions {
<<<<<<< HEAD
	allowInputInsideOutputPath?: boolean | undefined;
	buildDelay?: number | undefined;
	chokidar?: ChokidarOptions | undefined;
	clearScreen?: boolean | undefined;
	exclude?: string | RegExp | (string | RegExp)[] | undefined;
	include?: string | RegExp | (string | RegExp)[] | undefined;
	skipWrite?: boolean | undefined;
	onInvalidate?: ((id: string) => void) | undefined;
}

export interface RollupWatchOptions extends InputOptions {
	output?: OutputOptions | OutputOptions[] | undefined;
	watch?: WatcherOptions | false | undefined;
}

export type AwaitedEventListener<
	T extends Record<string, (...parameters: any) => any>,
	K extends keyof T
> = (...parameters: Parameters<T[K]>) => void | Promise<void>;

export interface AwaitingEventEmitter<T extends Record<string, (...parameters: any) => any>> {
	close(): Promise<void>;
	emit<K extends keyof T>(event: K, ...parameters: Parameters<T[K]>): Promise<unknown>;
	/**
	 * Removes an event listener.
	 */
	off<K extends keyof T>(event: K, listener: AwaitedEventListener<T, K>): this;
	/**
	 * Registers an event listener that will be awaited before Rollup continues.
	 * All listeners will be awaited in parallel while rejections are tracked via
	 * Promise.all.
	 */
	on<K extends keyof T>(event: K, listener: AwaitedEventListener<T, K>): this;
	/**
	 * Registers an event listener that will be awaited before Rollup continues.
	 * All listeners will be awaited in parallel while rejections are tracked via
	 * Promise.all.
	 * Listeners are removed automatically when removeListenersForCurrentRun is
	 * called, which happens automatically after each run.
	 */
	onCurrentRun<K extends keyof T>(
		event: K,
		listener: (...parameters: Parameters<T[K]>) => Promise<ReturnType<T[K]>>
	): this;
	removeAllListeners(): this;
	removeListenersForCurrentRun(): this;
=======
	buildDelay?: number;
	chokidar?: ChokidarOptions;
	clearScreen?: boolean;
	exclude?: string | RegExp | (string | RegExp)[];
	include?: string | RegExp | (string | RegExp)[];
	skipWrite?: boolean;
}

export interface RollupWatchOptions extends InputOptions {
	output?: OutputOptions | OutputOptions[];
	watch?: WatcherOptions | false;
}

interface TypedEventEmitter<T extends { [event: string]: (...args: any) => any }> {
	addListener<K extends keyof T>(event: K, listener: T[K]): this;
	emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>): boolean;
	eventNames(): Array<keyof T>;
	getMaxListeners(): number;
	listenerCount(type: keyof T): number;
	listeners<K extends keyof T>(event: K): Array<T[K]>;
	off<K extends keyof T>(event: K, listener: T[K]): this;
	on<K extends keyof T>(event: K, listener: T[K]): this;
	once<K extends keyof T>(event: K, listener: T[K]): this;
	prependListener<K extends keyof T>(event: K, listener: T[K]): this;
	prependOnceListener<K extends keyof T>(event: K, listener: T[K]): this;
	rawListeners<K extends keyof T>(event: K): Array<T[K]>;
	removeAllListeners<K extends keyof T>(event?: K): this;
	removeListener<K extends keyof T>(event: K, listener: T[K]): this;
	setMaxListeners(n: number): this;
}

export interface RollupAwaitingEmitter<T extends { [event: string]: (...args: any) => any }>
	extends TypedEventEmitter<T> {
	close(): Promise<void>;
	emitAndAwait<K extends keyof T>(event: K, ...args: Parameters<T[K]>): Promise<ReturnType<T[K]>[]>;
	/**
	 * Registers an event listener that will be awaited before Rollup continues
	 * for events emitted via emitAndAwait. All listeners will be awaited in
	 * parallel while rejections are tracked via Promise.all.
	 * Listeners are removed automatically when removeAwaited is called, which
	 * happens automatically after each run.
	 */
	onCurrentAwaited<K extends keyof T>(
		event: K,
		listener: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>>
	): this;
	removeAwaited(): this;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
}

export type RollupWatcherEvent =
	| { code: 'START' }
<<<<<<< HEAD
	| { code: 'BUNDLE_START'; input?: InputOption | undefined; output: readonly string[] }
	| {
			code: 'BUNDLE_END';
			duration: number;
			input?: InputOption | undefined;
=======
	| { code: 'BUNDLE_START'; input?: InputOption; output: readonly string[] }
	| {
			code: 'BUNDLE_END';
			duration: number;
			input?: InputOption;
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
			output: readonly string[];
			result: RollupBuild;
	  }
	| { code: 'END' }
	| { code: 'ERROR'; error: RollupError; result: RollupBuild | null };

<<<<<<< HEAD
export type RollupWatcher = AwaitingEventEmitter<{
=======
export type RollupWatcher = RollupAwaitingEmitter<{
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
	change: (id: string, change: { event: ChangeEvent }) => void;
	close: () => void;
	event: (event: RollupWatcherEvent) => void;
	restart: () => void;
}>;

export function watch(config: RollupWatchOptions | RollupWatchOptions[]): RollupWatcher;

<<<<<<< HEAD
interface AstNodeLocation {
	end: number;
	start: number;
}

type OmittedEstreeKeys =
	| 'loc'
	| 'range'
	| 'leadingComments'
	| 'trailingComments'
	| 'innerComments'
	| 'comments';
type RollupAstNode<T> = Omit<T, OmittedEstreeKeys> & AstNodeLocation;

type ProgramNode = RollupAstNode<estree.Program>;
export type AstNode = RollupAstNode<estree.Node>;

export function defineConfig(options: RollupOptions): RollupOptions;
export function defineConfig(options: RollupOptions[]): RollupOptions[];
export function defineConfig(optionsFunction: RollupOptionsFunction): RollupOptionsFunction;

export type RollupOptionsFunction = (
	commandLineArguments: Record<string, any>
) => MaybePromise<RollupOptions | RollupOptions[]>;

export interface RollupFsModule {
	appendFile(
		path: string,
		data: string | Uint8Array,
		options?: { encoding?: BufferEncoding | null; mode?: string | number; flag?: string | number }
	): Promise<void>;

	copyFile(source: string, destination: string, mode?: string | number): Promise<void>;

	mkdir(path: string, options?: { recursive?: boolean; mode?: string | number }): Promise<void>;

	mkdtemp(prefix: string): Promise<string>;

	readdir(path: string, options?: { withFileTypes?: false }): Promise<string[]>;
	readdir(path: string, options?: { withFileTypes: true }): Promise<RollupDirectoryEntry[]>;

	readFile(
		path: string,
		options?: { encoding?: null; flag?: string | number; signal?: AbortSignal }
	): Promise<Uint8Array>;
	readFile(
		path: string,
		options?: { encoding: BufferEncoding; flag?: string | number; signal?: AbortSignal }
	): Promise<string>;

	realpath(path: string): Promise<string>;

	rename(oldPath: string, newPath: string): Promise<void>;

	rmdir(path: string, options?: { recursive?: boolean }): Promise<void>;

	stat(path: string): Promise<RollupFileStats>;

	lstat(path: string): Promise<RollupFileStats>;

	unlink(path: string): Promise<void>;

	writeFile(
		path: string,
		data: string | Uint8Array,
		options?: { encoding?: BufferEncoding | null; mode?: string | number; flag?: string | number }
	): Promise<void>;
}

export type BufferEncoding =
	| 'ascii'
	| 'utf8'
	| 'utf16le'
	| 'ucs2'
	| 'base64'
	| 'base64url'
	| 'latin1'
	| 'binary'
	| 'hex';

export interface RollupDirectoryEntry {
	isFile(): boolean;
	isDirectory(): boolean;
	isSymbolicLink(): boolean;
	name: string;
}

export interface RollupFileStats {
	isFile(): boolean;
	isDirectory(): boolean;
	isSymbolicLink(): boolean;
	size: number;
	mtime: Date;
	ctime: Date;
	atime: Date;
	birthtime: Date;
}
=======
interface AcornNode {
	end: number;
	start: number;
	type: string;
}

export function defineConfig(options: RollupOptions): RollupOptions;
export function defineConfig(options: RollupOptions[]): RollupOptions[];
>>>>>>> 051c9bc53f84e13788fad557f5c363445d8e3235
